/// A user with additional account details. Always the current user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// The user object.
    #[prost(message, optional, tag = "1")]
    pub user: ::std::option::Option<User>,
    /// The user's wallet data.
    #[prost(string, tag = "2")]
    pub wallet: std::string::String,
    /// The email address of the user.
    #[prost(string, tag = "3")]
    pub email: std::string::String,
    /// The devices which belong to the user's account.
    #[prost(message, repeated, tag = "4")]
    pub devices: ::std::vec::Vec<AccountDevice>,
    /// The custom id in the user's account.
    #[prost(string, tag = "5")]
    pub custom_id: std::string::String,
    /// The UNIX time when the user's email was verified.
    #[prost(message, optional, tag = "6")]
    pub verify_time: ::std::option::Option<::prost_types::Timestamp>,
}
/// Send a custom ID to the server. Used with authenticate/link/unlink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountCustom {
    /// A custom identifier.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "2")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send a device to the server. Used with authenticate/link/unlink and user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountDevice {
    /// A device identifier. Should be obtained by a platform-specific device API.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "2")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send an email with password to the server. Used with authenticate/link/unlink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountEmail {
    /// A valid RFC-5322 email address.
    #[prost(string, tag = "1")]
    pub email: std::string::String,
    /// A password for the user account.
    ///
    /// Ignored with unlink operations.
    #[prost(string, tag = "2")]
    pub password: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "3")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send a Facebook token to the server. Used with authenticate/link/unlink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountFacebook {
    /// The OAuth token received from Facebook to access their profile API.
    #[prost(string, tag = "1")]
    pub token: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "2")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
///
/// https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountGameCenter {
    /// Player ID (generated by GameCenter).
    #[prost(string, tag = "1")]
    pub player_id: std::string::String,
    /// Bundle ID (generated by GameCenter).
    #[prost(string, tag = "2")]
    pub bundle_id: std::string::String,
    /// Time since UNIX epoch when the signature was created.
    #[prost(int64, tag = "3")]
    pub timestamp_seconds: i64,
    /// A random "NSString" used to compute the hash and keep it randomized.
    #[prost(string, tag = "4")]
    pub salt: std::string::String,
    /// The verification signature data generated.
    #[prost(string, tag = "5")]
    pub signature: std::string::String,
    /// The URL for the public encryption key.
    #[prost(string, tag = "6")]
    pub public_key_url: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "7")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send a Google token to the server. Used with authenticate/link/unlink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountGoogle {
    /// The OAuth token received from Google to access their profile API.
    #[prost(string, tag = "1")]
    pub token: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "2")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Send a Steam token to the server. Used with authenticate/link/unlink.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountSteam {
    /// The account token received from Steam to access their profile API.
    #[prost(string, tag = "1")]
    pub token: std::string::String,
    /// Extra information that will be bundled in the session token.
    #[prost(map = "string, string", tag = "2")]
    pub vars: ::std::collections::HashMap<std::string::String, std::string::String>,
}
/// Add one or more friends to the current user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddFriendsRequest {
    /// The account id of a user.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::std::vec::Vec<std::string::String>,
    /// The account username of a user.
    #[prost(string, repeated, tag = "2")]
    pub usernames: ::std::vec::Vec<std::string::String>,
}
/// Add users to a group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddGroupUsersRequest {
    /// The group to add users to.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
    /// The users to add.
    #[prost(string, repeated, tag = "2")]
    pub user_ids: ::std::vec::Vec<std::string::String>,
}
/// Authenticate against the server with a custom ID.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateCustomRequest {
    /// The custom account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountCustom>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Authenticate against the server with a device ID.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateDeviceRequest {
    /// The device account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountDevice>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Authenticate against the server with email+password.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateEmailRequest {
    /// The email account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountEmail>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Authenticate against the server with Facebook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateFacebookRequest {
    /// The Facebook account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountFacebook>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
    /// Import Facebook friends for the user.
    #[prost(message, optional, tag = "4")]
    pub sync: ::std::option::Option<bool>,
}
/// Authenticate against the server with Apple's Game Center.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateGameCenterRequest {
    /// The Game Center account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountGameCenter>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Authenticate against the server with Google.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateGoogleRequest {
    /// The Google account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountGoogle>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Authenticate against the server with Steam.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticateSteamRequest {
    /// The Steam account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountSteam>,
    /// Register the account if the user does not already exist.
    #[prost(message, optional, tag = "2")]
    pub create: ::std::option::Option<bool>,
    /// Set the username on the account at register. Must be unique.
    #[prost(string, tag = "3")]
    pub username: std::string::String,
}
/// Block one or more friends for the current user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockFriendsRequest {
    /// The account id of a user.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::std::vec::Vec<std::string::String>,
    /// The account username of a user.
    #[prost(string, repeated, tag = "2")]
    pub usernames: ::std::vec::Vec<std::string::String>,
}
/// A message sent on a channel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelMessage {
    /// The channel this message belongs to.
    #[prost(string, tag = "1")]
    pub channel_id: std::string::String,
    /// The unique ID of this message.
    #[prost(string, tag = "2")]
    pub message_id: std::string::String,
    /// The code representing a message type or category.
    #[prost(message, optional, tag = "3")]
    pub code: ::std::option::Option<i32>,
    /// Message sender, usually a user ID.
    #[prost(string, tag = "4")]
    pub sender_id: std::string::String,
    /// The username of the message sender, if any.
    #[prost(string, tag = "5")]
    pub username: std::string::String,
    /// The content payload.
    #[prost(string, tag = "6")]
    pub content: std::string::String,
    /// The UNIX time when the message was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the message was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// True if the message was persisted to the channel's history, false otherwise.
    #[prost(message, optional, tag = "9")]
    pub persistent: ::std::option::Option<bool>,
    /// The name of the chat room, or an empty string if this message was not sent through a chat room.
    #[prost(string, tag = "10")]
    pub room_name: std::string::String,
    /// The ID of the group, or an empty string if this message was not sent through a group channel.
    #[prost(string, tag = "11")]
    pub group_id: std::string::String,
    /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
    #[prost(string, tag = "12")]
    pub user_id_one: std::string::String,
    /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
    #[prost(string, tag = "13")]
    pub user_id_two: std::string::String,
}
/// A list of channel messages, usually a result of a list operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelMessageList {
    /// A list of messages.
    #[prost(message, repeated, tag = "1")]
    pub messages: ::std::vec::Vec<ChannelMessage>,
    /// The cursor to send when retireving the next page, if any.
    #[prost(string, tag = "2")]
    pub next_cursor: std::string::String,
    /// The cursor to send when retrieving the previous page, if any.
    #[prost(string, tag = "3")]
    pub prev_cursor: std::string::String,
}
/// Create a group with the current user as owner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    /// A unique name for the group.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// A description for the group.
    #[prost(string, tag = "2")]
    pub description: std::string::String,
    /// The language expected to be a tag which follows the BCP-47 spec.
    #[prost(string, tag = "3")]
    pub lang_tag: std::string::String,
    /// A URL for an avatar image.
    #[prost(string, tag = "4")]
    pub avatar_url: std::string::String,
    /// Mark a group as open or not where only admins can accept members.
    #[prost(bool, tag = "5")]
    pub open: bool,
    /// Maximum number of group members.
    #[prost(int32, tag = "6")]
    pub max_count: i32,
}
/// Delete one or more friends for the current user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFriendsRequest {
    /// The account id of a user.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::std::vec::Vec<std::string::String>,
    /// The account username of a user.
    #[prost(string, repeated, tag = "2")]
    pub usernames: ::std::vec::Vec<std::string::String>,
}
/// Delete a group the user has access to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    /// The id of a group.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
}
/// Delete a leaderboard record.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLeaderboardRecordRequest {
    /// The leaderboard ID to delete from.
    #[prost(string, tag = "1")]
    pub leaderboard_id: std::string::String,
}
/// Delete one or more notifications for the current user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotificationsRequest {
    /// The id of notifications.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::std::vec::Vec<std::string::String>,
}
/// Storage objects to delete.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStorageObjectId {
    /// The collection which stores the object.
    #[prost(string, tag = "1")]
    pub collection: std::string::String,
    /// The key of the object within the collection.
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    /// The version hash of the object.
    #[prost(string, tag = "3")]
    pub version: std::string::String,
}
/// Batch delete storage objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStorageObjectsRequest {
    /// Batch of storage objects.
    #[prost(message, repeated, tag = "1")]
    pub object_ids: ::std::vec::Vec<DeleteStorageObjectId>,
}
/// Represents an event to be passed through the server to registered event handlers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// An event name, type, category, or identifier.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Arbitrary event property values.
    #[prost(map = "string, string", tag = "2")]
    pub properties: ::std::collections::HashMap<std::string::String, std::string::String>,
    /// The time when the event was triggered.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::std::option::Option<::prost_types::Timestamp>,
}
/// A friend of a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Friend {
    /// The user object.
    #[prost(message, optional, tag = "1")]
    pub user: ::std::option::Option<User>,
    /// The friend status.
    ///
    /// one of "Friend.State".
    #[prost(message, optional, tag = "2")]
    pub state: ::std::option::Option<i32>,
}
pub mod friend {
    /// The friendship status.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        /// The user is a friend of the current user.
        Friend = 0,
        /// The current user has sent an invite to the user.
        InviteSent = 1,
        /// The current user has received an invite from this user.
        InviteReceived = 2,
        /// The current user has blocked this user.
        Blocked = 3,
    }
}
/// A collection of zero or more friends of the user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FriendList {
    /// The Friend objects.
    #[prost(message, repeated, tag = "1")]
    pub friends: ::std::vec::Vec<Friend>,
    /// Cursor for the next page of results, if any.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
/// Fetch a batch of zero or more users from the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsersRequest {
    /// The account id of a user.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::std::vec::Vec<std::string::String>,
    /// The account username of a user.
    #[prost(string, repeated, tag = "2")]
    pub usernames: ::std::vec::Vec<std::string::String>,
    /// The Facebook ID of a user.
    #[prost(string, repeated, tag = "3")]
    pub facebook_ids: ::std::vec::Vec<std::string::String>,
}
/// A group in the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    /// The id of a group.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// The id of the user who created the group.
    #[prost(string, tag = "2")]
    pub creator_id: std::string::String,
    /// The unique name of the group.
    #[prost(string, tag = "3")]
    pub name: std::string::String,
    /// A description for the group.
    #[prost(string, tag = "4")]
    pub description: std::string::String,
    /// The language expected to be a tag which follows the BCP-47 spec.
    #[prost(string, tag = "5")]
    pub lang_tag: std::string::String,
    /// Additional information stored as a JSON object.
    #[prost(string, tag = "6")]
    pub metadata: std::string::String,
    /// A URL for an avatar image.
    #[prost(string, tag = "7")]
    pub avatar_url: std::string::String,
    /// Anyone can join open groups, otherwise only admins can accept members.
    #[prost(message, optional, tag = "8")]
    pub open: ::std::option::Option<bool>,
    /// The current count of all members in the group.
    #[prost(int32, tag = "9")]
    pub edge_count: i32,
    /// The maximum number of members allowed.
    #[prost(int32, tag = "10")]
    pub max_count: i32,
    /// The UNIX time when the group was created.
    #[prost(message, optional, tag = "11")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the group was last updated.
    #[prost(message, optional, tag = "12")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
}
/// One or more groups returned from a listing operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupList {
    /// One or more groups.
    #[prost(message, repeated, tag = "1")]
    pub groups: ::std::vec::Vec<Group>,
    /// A cursor used to get the next page.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
/// A list of users belonging to a group, along with their role.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupUserList {
    /// User-role pairs for a group.
    #[prost(message, repeated, tag = "1")]
    pub group_users: ::std::vec::Vec<group_user_list::GroupUser>,
    /// Cursor for the next page of results, if any.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
pub mod group_user_list {
    /// A single user-role pair.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupUser {
        /// User.
        #[prost(message, optional, tag = "1")]
        pub user: ::std::option::Option<super::User>,
        /// Their relationship to the group.
        #[prost(message, optional, tag = "2")]
        pub state: ::std::option::Option<i32>,
    }
    pub mod group_user {
        /// The group role status.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum State {
            /// The user is a superadmin with full control of the group.
            Superadmin = 0,
            /// The user is an admin with additional privileges.
            Admin = 1,
            /// The user is a regular member.
            Member = 2,
            /// The user has requested to join the group
            JoinRequest = 3,
        }
    }
}
/// Import Facebook friends into the current user's account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportFacebookFriendsRequest {
    /// The Facebook account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountFacebook>,
    /// Reset the current user's friends list.
    #[prost(message, optional, tag = "2")]
    pub reset: ::std::option::Option<bool>,
}
/// Immediately join an open group, or request to join a closed one.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinGroupRequest {
    /// The group ID to join. The group must already exist.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
}
/// The request to join a tournament.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JoinTournamentRequest {
    /// The ID of the tournament to join. The tournament must already exist.
    #[prost(string, tag = "1")]
    pub tournament_id: std::string::String,
}
/// Kick a set of users from a group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KickGroupUsersRequest {
    /// The group ID to kick from.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
    /// The users to kick.
    #[prost(string, repeated, tag = "2")]
    pub user_ids: ::std::vec::Vec<std::string::String>,
}
/// Represents a complete leaderboard record with all scores and associated metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRecord {
    /// The ID of the leaderboard this score belongs to.
    #[prost(string, tag = "1")]
    pub leaderboard_id: std::string::String,
    /// The ID of the score owner, usually a user or group.
    #[prost(string, tag = "2")]
    pub owner_id: std::string::String,
    /// The username of the score owner, if the owner is a user.
    #[prost(message, optional, tag = "3")]
    pub username: ::std::option::Option<::std::string::String>,
    /// The score value.
    #[prost(int64, tag = "4")]
    pub score: i64,
    /// An optional subscore value.
    #[prost(int64, tag = "5")]
    pub subscore: i64,
    /// The number of submissions to this score record.
    #[prost(int32, tag = "6")]
    pub num_score: i32,
    /// Metadata.
    #[prost(string, tag = "7")]
    pub metadata: std::string::String,
    /// The UNIX time when the leaderboard record was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the leaderboard record was updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the leaderboard record expires.
    #[prost(message, optional, tag = "10")]
    pub expiry_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The rank of this record.
    #[prost(int64, tag = "11")]
    pub rank: i64,
    /// The maximum number of score updates allowed by the owner.
    #[prost(uint32, tag = "12")]
    pub max_num_score: u32,
}
/// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaderboardRecordList {
    /// A list of leaderboard records.
    #[prost(message, repeated, tag = "1")]
    pub records: ::std::vec::Vec<LeaderboardRecord>,
    /// A batched set of leaderboard records belonging to specified owners.
    #[prost(message, repeated, tag = "2")]
    pub owner_records: ::std::vec::Vec<LeaderboardRecord>,
    /// The cursor to send when retrieving the next page, if any.
    #[prost(string, tag = "3")]
    pub next_cursor: std::string::String,
    /// The cursor to send when retrieving the previous page, if any.
    #[prost(string, tag = "4")]
    pub prev_cursor: std::string::String,
}
/// Leave a group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaveGroupRequest {
    /// The group ID to leave.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
}
/// Link Facebook to the current user's account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkFacebookRequest {
    /// The Facebook account details.
    #[prost(message, optional, tag = "1")]
    pub account: ::std::option::Option<AccountFacebook>,
    /// Import Facebook friends for the user.
    #[prost(message, optional, tag = "4")]
    pub sync: ::std::option::Option<bool>,
}
/// List a channel's message history.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelMessagesRequest {
    /// The channel ID to list from.
    #[prost(string, tag = "1")]
    pub channel_id: std::string::String,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "2")]
    pub limit: ::std::option::Option<i32>,
    /// True if listing should be older messages to newer, false if reverse.
    #[prost(message, optional, tag = "3")]
    pub forward: ::std::option::Option<bool>,
    /// A pagination cursor, if any.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
}
/// List friends for a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFriendsRequest {
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "1")]
    pub limit: ::std::option::Option<i32>,
    /// The friend state to list.
    #[prost(message, optional, tag = "2")]
    pub state: ::std::option::Option<i32>,
    /// An optional next page cursor.
    #[prost(string, tag = "3")]
    pub cursor: std::string::String,
}
/// List groups based on given filters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {
    /// List groups that contain this value in their names.
    #[prost(string, tag = "1")]
    pub name: std::string::String,
    /// Optional pagination cursor.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
    /// Max number of groups to return. Between 1 and 100.
    #[prost(message, optional, tag = "3")]
    pub limit: ::std::option::Option<i32>,
}
/// List all users that are part of a group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupUsersRequest {
    /// The group ID to list from.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "2")]
    pub limit: ::std::option::Option<i32>,
    /// The group user state to list.
    #[prost(message, optional, tag = "3")]
    pub state: ::std::option::Option<i32>,
    /// An optional next page cursor.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
}
/// List leaerboard records from a given leaderboard around the owner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLeaderboardRecordsAroundOwnerRequest {
    /// The ID of the tournament to list for.
    #[prost(string, tag = "1")]
    pub leaderboard_id: std::string::String,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "2")]
    pub limit: ::std::option::Option<u32>,
    /// The owner to retrieve records around.
    #[prost(string, tag = "3")]
    pub owner_id: std::string::String,
    /// Expiry in seconds (since epoch) to begin fetching records from.
    #[prost(message, optional, tag = "4")]
    pub expiry: ::std::option::Option<i64>,
}
/// List leaderboard records from a given leaderboard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLeaderboardRecordsRequest {
    /// The ID of the leaderboard to list for.
    #[prost(string, tag = "1")]
    pub leaderboard_id: std::string::String,
    /// One or more owners to retrieve records for.
    #[prost(string, repeated, tag = "2")]
    pub owner_ids: ::std::vec::Vec<std::string::String>,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "3")]
    pub limit: ::std::option::Option<i32>,
    /// A next or previous page cursor.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
    /// Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
    #[prost(message, optional, tag = "5")]
    pub expiry: ::std::option::Option<i64>,
}
/// List realtime matches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMatchesRequest {
    /// Limit the number of returned matches.
    #[prost(message, optional, tag = "1")]
    pub limit: ::std::option::Option<i32>,
    /// Authoritative or relayed matches.
    #[prost(message, optional, tag = "2")]
    pub authoritative: ::std::option::Option<bool>,
    /// Label filter.
    #[prost(message, optional, tag = "3")]
    pub label: ::std::option::Option<::std::string::String>,
    /// Minimum user count.
    #[prost(message, optional, tag = "4")]
    pub min_size: ::std::option::Option<i32>,
    /// Maximum user count.
    #[prost(message, optional, tag = "5")]
    pub max_size: ::std::option::Option<i32>,
    /// Arbitrary label query.
    #[prost(message, optional, tag = "6")]
    pub query: ::std::option::Option<::std::string::String>,
}
/// Get a list of unexpired notifications.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationsRequest {
    /// The number of notifications to get. Between 1 and 100.
    #[prost(message, optional, tag = "1")]
    pub limit: ::std::option::Option<i32>,
    /// A cursor to page through notifications. May be cached by clients to get from point in time forwards.
    ///
    /// value from NotificationList.cacheable_cursor.
    #[prost(string, tag = "2")]
    pub cacheable_cursor: std::string::String,
}
/// List publicly readable storage objects in a given collection.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStorageObjectsRequest {
    /// ID of the user.
    #[prost(string, tag = "1")]
    pub user_id: std::string::String,
    /// The collection which stores the object.
    #[prost(string, tag = "2")]
    pub collection: std::string::String,
    /// The number of storage objects to list. Between 1 and 100.
    #[prost(message, optional, tag = "3")]
    pub limit: ::std::option::Option<i32>,
    /// The cursor to page through results from.
    ///
    /// value from StorageObjectList.cursor.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
}
/// List tournament records from a given tournament around the owner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTournamentRecordsAroundOwnerRequest {
    /// The ID of the tournament to list for.
    #[prost(string, tag = "1")]
    pub tournament_id: std::string::String,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "2")]
    pub limit: ::std::option::Option<u32>,
    /// The owner to retrieve records around.
    #[prost(string, tag = "3")]
    pub owner_id: std::string::String,
    /// Expiry in seconds (since epoch) to begin fetching records from.
    #[prost(message, optional, tag = "4")]
    pub expiry: ::std::option::Option<i64>,
}
/// List tournament records from a given tournament.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTournamentRecordsRequest {
    /// The ID of the tournament to list for.
    #[prost(string, tag = "1")]
    pub tournament_id: std::string::String,
    /// One or more owners to retrieve records for.
    #[prost(string, repeated, tag = "2")]
    pub owner_ids: ::std::vec::Vec<std::string::String>,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "3")]
    pub limit: ::std::option::Option<i32>,
    /// A next or previous page cursor.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
    /// Expiry in seconds (since epoch) to begin fetching records from.
    #[prost(message, optional, tag = "5")]
    pub expiry: ::std::option::Option<i64>,
}
/// List active/upcoming tournaments based on given filters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTournamentsRequest {
    /// The start of the categories to include. Defaults to 0.
    #[prost(message, optional, tag = "1")]
    pub category_start: ::std::option::Option<u32>,
    /// The end of the categories to include. Defaults to 128.
    #[prost(message, optional, tag = "2")]
    pub category_end: ::std::option::Option<u32>,
    /// The start time for tournaments. Defaults to epoch.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::std::option::Option<u32>,
    /// The end time for tournaments. Defaults to +1 year from current Unix time.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::std::option::Option<u32>,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "6")]
    pub limit: ::std::option::Option<i32>,
    /// A next page cursor for listings (optional).
    #[prost(string, tag = "8")]
    pub cursor: std::string::String,
}
/// List the groups a user is part of, and their relationship to each.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserGroupsRequest {
    /// ID of the user.
    #[prost(string, tag = "1")]
    pub user_id: std::string::String,
    /// Max number of records to return. Between 1 and 100.
    #[prost(message, optional, tag = "2")]
    pub limit: ::std::option::Option<i32>,
    /// The user group state to list.
    #[prost(message, optional, tag = "3")]
    pub state: ::std::option::Option<i32>,
    /// An optional next page cursor.
    #[prost(string, tag = "4")]
    pub cursor: std::string::String,
}
/// Represents a realtime match.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Match {
    /// The ID of the match, can be used to join.
    #[prost(string, tag = "1")]
    pub match_id: std::string::String,
    /// True if it's an server-managed authoritative match, false otherwise.
    #[prost(bool, tag = "2")]
    pub authoritative: bool,
    /// Match label, if any.
    #[prost(message, optional, tag = "3")]
    pub label: ::std::option::Option<::std::string::String>,
    /// Current number of users in the match.
    #[prost(int32, tag = "4")]
    pub size: i32,
}
/// A list of realtime matches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchList {
    /// A number of matches corresponding to a list operation.
    #[prost(message, repeated, tag = "1")]
    pub matches: ::std::vec::Vec<Match>,
}
/// A notification in the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    /// ID of the Notification.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// Subject of the notification.
    #[prost(string, tag = "2")]
    pub subject: std::string::String,
    /// Content of the notification in JSON.
    #[prost(string, tag = "3")]
    pub content: std::string::String,
    /// Category code for this notification.
    #[prost(int32, tag = "4")]
    pub code: i32,
    /// ID of the sender, if a user. Otherwise 'null'.
    #[prost(string, tag = "5")]
    pub sender_id: std::string::String,
    /// The UNIX time when the notification was created.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// True if this notification was persisted to the database.
    #[prost(bool, tag = "7")]
    pub persistent: bool,
}
/// A collection of zero or more notifications.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationList {
    /// Collection of notifications.
    #[prost(message, repeated, tag = "1")]
    pub notifications: ::std::vec::Vec<Notification>,
    /// Use this cursor to paginate notifications. Cache this to catch up to new notifications.
    #[prost(string, tag = "2")]
    pub cacheable_cursor: std::string::String,
}
/// Promote a set of users in a group to the next role up.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteGroupUsersRequest {
    /// The group ID to promote in.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
    /// The users to promote.
    #[prost(string, repeated, tag = "2")]
    pub user_ids: ::std::vec::Vec<std::string::String>,
}
/// Storage objects to get.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadStorageObjectId {
    /// The collection which stores the object.
    #[prost(string, tag = "1")]
    pub collection: std::string::String,
    /// The key of the object within the collection.
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    /// The user owner of the object.
    #[prost(string, tag = "3")]
    pub user_id: std::string::String,
}
/// Batch get storage objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadStorageObjectsRequest {
    /// Batch of storage objects.
    #[prost(message, repeated, tag = "1")]
    pub object_ids: ::std::vec::Vec<ReadStorageObjectId>,
}
/// Execute an Lua function on the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rpc {
    /// The identifier of the function.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// The payload of the function which must be a JSON object.
    #[prost(string, tag = "2")]
    pub payload: std::string::String,
    /// The authentication key used when executed as a non-client HTTP request.
    #[prost(string, tag = "3")]
    pub http_key: std::string::String,
}
/// A user's session used to authenticate messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    /// True if the corresponding account was just created, false otherwise.
    #[prost(bool, tag = "1")]
    pub created: bool,
    /// Authentication credentials.
    #[prost(string, tag = "2")]
    pub token: std::string::String,
}
/// An object within the storage engine.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageObject {
    /// The collection which stores the object.
    #[prost(string, tag = "1")]
    pub collection: std::string::String,
    /// The key of the object within the collection.
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    /// The user owner of the object.
    #[prost(string, tag = "3")]
    pub user_id: std::string::String,
    /// The value of the object.
    #[prost(string, tag = "4")]
    pub value: std::string::String,
    /// The version hash of the object.
    #[prost(string, tag = "5")]
    pub version: std::string::String,
    /// The read access permissions for the object.
    #[prost(int32, tag = "6")]
    pub permission_read: i32,
    /// The write access permissions for the object.
    #[prost(int32, tag = "7")]
    pub permission_write: i32,
    /// The UNIX time when the object was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the object was last updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
}
/// A storage acknowledgement.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageObjectAck {
    /// The collection which stores the object.
    #[prost(string, tag = "1")]
    pub collection: std::string::String,
    /// The key of the object within the collection.
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    /// The version hash of the object.
    #[prost(string, tag = "3")]
    pub version: std::string::String,
    /// The owner of the object.
    #[prost(string, tag = "4")]
    pub user_id: std::string::String,
}
/// Batch of acknowledgements for the storage object write.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageObjectAcks {
    /// Batch of storage write acknowledgements.
    #[prost(message, repeated, tag = "1")]
    pub acks: ::std::vec::Vec<StorageObjectAck>,
}
/// Batch of storage objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageObjects {
    /// The batch of storage objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::std::vec::Vec<StorageObject>,
}
/// List of storage objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageObjectList {
    /// The list of storage objects.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::std::vec::Vec<StorageObject>,
    /// The cursor for the next page of results, if any.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
/// A tournament on the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tournament {
    /// The ID of the tournament.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// The title for the tournament.
    #[prost(string, tag = "2")]
    pub title: std::string::String,
    /// The description of the tournament. May be blank.
    #[prost(string, tag = "3")]
    pub description: std::string::String,
    /// The category of the tournament. e.g. "vip" could be category 1.
    #[prost(uint32, tag = "4")]
    pub category: u32,
    /// ASC or DESC sort mode of scores in the tournament.
    #[prost(uint32, tag = "5")]
    pub sort_order: u32,
    /// The current number of players in the tournament.
    #[prost(uint32, tag = "6")]
    pub size: u32,
    /// The maximum number of players for the tournament.
    #[prost(uint32, tag = "7")]
    pub max_size: u32,
    /// The maximum score updates allowed per player for the current tournament.
    #[prost(uint32, tag = "8")]
    pub max_num_score: u32,
    /// True if the tournament is active and can enter. A computed value.
    #[prost(bool, tag = "9")]
    pub can_enter: bool,
    /// The UNIX time when the tournament stops being active until next reset. A computed value.
    #[prost(uint32, tag = "10")]
    pub end_active: u32,
    /// The UNIX time when the tournament is next playable. A computed value.
    #[prost(uint32, tag = "11")]
    pub next_reset: u32,
    /// Additional information stored as a JSON object.
    #[prost(string, tag = "12")]
    pub metadata: std::string::String,
    /// The UNIX time when the tournament was created.
    #[prost(message, optional, tag = "13")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the tournament will start.
    #[prost(message, optional, tag = "14")]
    pub start_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the tournament will be stopped.
    #[prost(message, optional, tag = "15")]
    pub end_time: ::std::option::Option<::prost_types::Timestamp>,
    /// Duration of the tournament in seconds.
    #[prost(uint32, tag = "16")]
    pub duration: u32,
    /// The UNIX time when the tournament start being active. A computed value.
    #[prost(uint32, tag = "17")]
    pub start_active: u32,
}
/// A list of tournaments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentList {
    /// The list of tournaments returned.
    #[prost(message, repeated, tag = "1")]
    pub tournaments: ::std::vec::Vec<Tournament>,
    /// A pagination cursor (optional).
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
/// A set of tournament records which may be part of a tournament records page or a batch of individual records.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentRecordList {
    /// A list of tournament records.
    #[prost(message, repeated, tag = "1")]
    pub records: ::std::vec::Vec<LeaderboardRecord>,
    /// A batched set of tournament records belonging to specified owners.
    #[prost(message, repeated, tag = "2")]
    pub owner_records: ::std::vec::Vec<LeaderboardRecord>,
    /// The cursor to send when retireving the next page (optional).
    #[prost(string, tag = "3")]
    pub next_cursor: std::string::String,
    /// The cursor to send when retrieving the previous page (optional).
    #[prost(string, tag = "4")]
    pub prev_cursor: std::string::String,
}
/// Update a user's account details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountRequest {
    /// The username of the user's account.
    #[prost(message, optional, tag = "1")]
    pub username: ::std::option::Option<::std::string::String>,
    /// The display name of the user.
    #[prost(message, optional, tag = "2")]
    pub display_name: ::std::option::Option<::std::string::String>,
    /// A URL for an avatar image.
    #[prost(message, optional, tag = "3")]
    pub avatar_url: ::std::option::Option<::std::string::String>,
    /// The language expected to be a tag which follows the BCP-47 spec.
    #[prost(message, optional, tag = "4")]
    pub lang_tag: ::std::option::Option<::std::string::String>,
    /// The location set by the user.
    #[prost(message, optional, tag = "5")]
    pub location: ::std::option::Option<::std::string::String>,
    /// The timezone set by the user.
    #[prost(message, optional, tag = "6")]
    pub timezone: ::std::option::Option<::std::string::String>,
}
/// Update fields in a given group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGroupRequest {
    /// The ID of the group to update.
    #[prost(string, tag = "1")]
    pub group_id: std::string::String,
    /// Name.
    #[prost(message, optional, tag = "2")]
    pub name: ::std::option::Option<::std::string::String>,
    /// Description string.
    #[prost(message, optional, tag = "3")]
    pub description: ::std::option::Option<::std::string::String>,
    /// Lang tag.
    #[prost(message, optional, tag = "4")]
    pub lang_tag: ::std::option::Option<::std::string::String>,
    /// Avatar URL.
    #[prost(message, optional, tag = "5")]
    pub avatar_url: ::std::option::Option<::std::string::String>,
    /// Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
    #[prost(message, optional, tag = "6")]
    pub open: ::std::option::Option<bool>,
}
/// A user in the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// The id of the user's account.
    #[prost(string, tag = "1")]
    pub id: std::string::String,
    /// The username of the user's account.
    #[prost(string, tag = "2")]
    pub username: std::string::String,
    /// The display name of the user.
    #[prost(string, tag = "3")]
    pub display_name: std::string::String,
    /// A URL for an avatar image.
    #[prost(string, tag = "4")]
    pub avatar_url: std::string::String,
    /// The language expected to be a tag which follows the BCP-47 spec.
    #[prost(string, tag = "5")]
    pub lang_tag: std::string::String,
    /// The location set by the user.
    #[prost(string, tag = "6")]
    pub location: std::string::String,
    /// The timezone set by the user.
    #[prost(string, tag = "7")]
    pub timezone: std::string::String,
    /// Additional information stored as a JSON object.
    #[prost(string, tag = "8")]
    pub metadata: std::string::String,
    /// The Facebook id in the user's account.
    #[prost(string, tag = "9")]
    pub facebook_id: std::string::String,
    /// The Google id in the user's account.
    #[prost(string, tag = "10")]
    pub google_id: std::string::String,
    /// The Apple Game Center in of the user's account.
    #[prost(string, tag = "11")]
    pub gamecenter_id: std::string::String,
    /// The Steam id in the user's account.
    #[prost(string, tag = "12")]
    pub steam_id: std::string::String,
    /// Indicates whether the user is currently online.
    #[prost(bool, tag = "13")]
    pub online: bool,
    /// Number of related edges to this user.
    #[prost(int32, tag = "14")]
    pub edge_count: i32,
    /// The UNIX time when the user was created.
    #[prost(message, optional, tag = "15")]
    pub create_time: ::std::option::Option<::prost_types::Timestamp>,
    /// The UNIX time when the user was last updated.
    #[prost(message, optional, tag = "16")]
    pub update_time: ::std::option::Option<::prost_types::Timestamp>,
}
/// A list of groups belonging to a user, along with the user's role in each group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserGroupList {
    /// Group-role pairs for a user.
    #[prost(message, repeated, tag = "1")]
    pub user_groups: ::std::vec::Vec<user_group_list::UserGroup>,
    /// Cursor for the next page of results, if any.
    #[prost(string, tag = "2")]
    pub cursor: std::string::String,
}
pub mod user_group_list {
    /// A single group-role pair.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserGroup {
        /// Group.
        #[prost(message, optional, tag = "1")]
        pub group: ::std::option::Option<super::Group>,
        /// The user's relationship to the group.
        #[prost(message, optional, tag = "2")]
        pub state: ::std::option::Option<i32>,
    }
    pub mod user_group {
        /// The group role status.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum State {
            /// The user is a superadmin with full control of the group.
            Superadmin = 0,
            /// The user is an admin with additional privileges.
            Admin = 1,
            /// The user is a regular member.
            Member = 2,
            /// The user has requested to join the group
            JoinRequest = 3,
        }
    }
}
/// A collection of zero or more users.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Users {
    /// The User objects.
    #[prost(message, repeated, tag = "1")]
    pub users: ::std::vec::Vec<User>,
}
/// A request to submit a score to a leaderboard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteLeaderboardRecordRequest {
    /// The ID of the leaderboard to write to.
    #[prost(string, tag = "1")]
    pub leaderboard_id: std::string::String,
    /// Record input.
    #[prost(message, optional, tag = "2")]
    pub record: ::std::option::Option<write_leaderboard_record_request::LeaderboardRecordWrite>,
}
pub mod write_leaderboard_record_request {
    /// Record values to write.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LeaderboardRecordWrite {
        /// The score value to submit.
        #[prost(int64, tag = "1")]
        pub score: i64,
        /// An optional secondary value.
        #[prost(int64, tag = "2")]
        pub subscore: i64,
        /// Optional record metadata.
        #[prost(string, tag = "3")]
        pub metadata: std::string::String,
    }
}
/// The object to store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteStorageObject {
    /// The collection to store the object.
    #[prost(string, tag = "1")]
    pub collection: std::string::String,
    /// The key for the object within the collection.
    #[prost(string, tag = "2")]
    pub key: std::string::String,
    /// The value of the object.
    #[prost(string, tag = "3")]
    pub value: std::string::String,
    /// The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
    ///
    /// if-match and if-none-match
    #[prost(string, tag = "4")]
    pub version: std::string::String,
    /// The read access permissions for the object.
    #[prost(message, optional, tag = "5")]
    pub permission_read: ::std::option::Option<i32>,
    /// The write access permissions for the object.
    #[prost(message, optional, tag = "6")]
    pub permission_write: ::std::option::Option<i32>,
}
/// Write objects to the storage engine.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteStorageObjectsRequest {
    /// The objects to store on the server.
    #[prost(message, repeated, tag = "1")]
    pub objects: ::std::vec::Vec<WriteStorageObject>,
}
/// A request to submit a score to a tournament.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteTournamentRecordRequest {
    /// The tournament ID to write the record for.
    #[prost(string, tag = "1")]
    pub tournament_id: std::string::String,
    /// Record input.
    #[prost(message, optional, tag = "2")]
    pub record: ::std::option::Option<write_tournament_record_request::TournamentRecordWrite>,
}
pub mod write_tournament_record_request {
    /// Record values to write.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TournamentRecordWrite {
        /// The score value to submit.
        #[prost(int64, tag = "1")]
        pub score: i64,
        /// An optional secondary value.
        #[prost(int64, tag = "2")]
        pub subscore: i64,
        /// A JSON object of additional properties (optional).
        #[prost(string, tag = "3")]
        pub metadata: std::string::String,
    }
}
#[doc = r" Generated client implementations."]
pub mod client {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "*"]
    #[doc = " The Rearward RPC protocol service built with GRPC."]
    pub struct RearwardServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RearwardServiceClient<tonic::transport::Channel> {
        #[doc = r" Attempt to create a new client by connecting to a given endpoint."]
        pub fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: std::convert::TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            tonic::transport::Endpoint::new(dst).map(|c| Self::new(c.channel()))
        }
    }
    impl<T> RearwardServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::ResponseBody: Body + HttpBody + Send + 'static,
        T::Error: Into<StdError>,
        <T::ResponseBody as HttpBody>::Error: Into<StdError> + Send,
        <T::ResponseBody as HttpBody>::Data: Into<bytes::Bytes> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        #[doc = r" Check if the service is ready."]
        pub async fn ready(&mut self) -> Result<(), tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })
        }
        #[doc = " Add friends by ID or username to a user's account."]
        pub async fn add_friends(
            &mut self,
            request: tonic::Request<super::AddFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/AddFriends");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add users to a group."]
        pub async fn add_group_users(
            &mut self,
            request: tonic::Request<super::AddGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/AddGroupUsers");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with a custom id against the server."]
        pub async fn authenticate_custom(
            &mut self,
            request: tonic::Request<super::AuthenticateCustomRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateCustom",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with a device id against the server."]
        pub async fn authenticate_device(
            &mut self,
            request: tonic::Request<super::AuthenticateDeviceRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateDevice",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with an email+password against the server."]
        pub async fn authenticate_email(
            &mut self,
            request: tonic::Request<super::AuthenticateEmailRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateEmail",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with a Facebook OAuth token against the server."]
        pub async fn authenticate_facebook(
            &mut self,
            request: tonic::Request<super::AuthenticateFacebookRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateFacebook",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with Apple's GameCenter against the server."]
        pub async fn authenticate_game_center(
            &mut self,
            request: tonic::Request<super::AuthenticateGameCenterRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateGameCenter",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with Google against the server."]
        pub async fn authenticate_google(
            &mut self,
            request: tonic::Request<super::AuthenticateGoogleRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateGoogle",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Authenticate a user with Steam against the server."]
        pub async fn authenticate_steam(
            &mut self,
            request: tonic::Request<super::AuthenticateSteamRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/AuthenticateSteam",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Block one or more users by ID or username."]
        pub async fn block_friends(
            &mut self,
            request: tonic::Request<super::BlockFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/BlockFriends");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Create a new group with the current user as the owner."]
        pub async fn create_group(
            &mut self,
            request: tonic::Request<super::CreateGroupRequest>,
        ) -> Result<tonic::Response<super::Group>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/CreateGroup");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Delete one or more users by ID or username."]
        pub async fn delete_friends(
            &mut self,
            request: tonic::Request<super::DeleteFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/DeleteFriends");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Delete a group by ID."]
        pub async fn delete_group(
            &mut self,
            request: tonic::Request<super::DeleteGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/DeleteGroup");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Delete a leaderboard record."]
        pub async fn delete_leaderboard_record(
            &mut self,
            request: tonic::Request<super::DeleteLeaderboardRecordRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/DeleteLeaderboardRecord",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Delete one or more notifications for the current user."]
        pub async fn delete_notifications(
            &mut self,
            request: tonic::Request<super::DeleteNotificationsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/DeleteNotifications",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Delete one or more objects by ID or username."]
        pub async fn delete_storage_objects(
            &mut self,
            request: tonic::Request<super::DeleteStorageObjectsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/DeleteStorageObjects",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Fetch the current user's account."]
        pub async fn get_account(
            &mut self,
            request: tonic::Request<()>,
        ) -> Result<tonic::Response<super::Account>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/GetAccount");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Fetch zero or more users by ID and/or username."]
        pub async fn get_users(
            &mut self,
            request: tonic::Request<super::GetUsersRequest>,
        ) -> Result<tonic::Response<super::Users>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/GetUsers");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " A healthcheck which load balancers can use to check the service."]
        pub async fn healthcheck(
            &mut self,
            request: tonic::Request<()>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/Healthcheck");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Import Facebook friends and add them to a user's account."]
        pub async fn import_facebook_friends(
            &mut self,
            request: tonic::Request<super::ImportFacebookFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ImportFacebookFriends",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Immediately join an open group, or request to join a closed one."]
        pub async fn join_group(
            &mut self,
            request: tonic::Request<super::JoinGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/JoinGroup");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Attempt to join an open and running tournament."]
        pub async fn join_tournament(
            &mut self,
            request: tonic::Request<super::JoinTournamentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/JoinTournament",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Kick a set of users from a group."]
        pub async fn kick_group_users(
            &mut self,
            request: tonic::Request<super::KickGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/KickGroupUsers",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Leave a group the user is a member of."]
        pub async fn leave_group(
            &mut self,
            request: tonic::Request<super::LeaveGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LeaveGroup");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add a custom ID to the social profiles on the current user's account."]
        pub async fn link_custom(
            &mut self,
            request: tonic::Request<super::AccountCustom>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkCustom");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add a device ID to the social profiles on the current user's account."]
        pub async fn link_device(
            &mut self,
            request: tonic::Request<super::AccountDevice>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkDevice");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add an email+password to the social profiles on the current user's account."]
        pub async fn link_email(
            &mut self,
            request: tonic::Request<super::AccountEmail>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkEmail");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add Facebook to the social profiles on the current user's account."]
        pub async fn link_facebook(
            &mut self,
            request: tonic::Request<super::LinkFacebookRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkFacebook");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add Apple's GameCenter to the social profiles on the current user's account."]
        pub async fn link_game_center(
            &mut self,
            request: tonic::Request<super::AccountGameCenter>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/LinkGameCenter",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add Google to the social profiles on the current user's account."]
        pub async fn link_google(
            &mut self,
            request: tonic::Request<super::AccountGoogle>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkGoogle");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Add Steam to the social profiles on the current user's account."]
        pub async fn link_steam(
            &mut self,
            request: tonic::Request<super::AccountSteam>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/LinkSteam");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List a channel's message history."]
        pub async fn list_channel_messages(
            &mut self,
            request: tonic::Request<super::ListChannelMessagesRequest>,
        ) -> Result<tonic::Response<super::ChannelMessageList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListChannelMessages",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List all friends for the current user."]
        pub async fn list_friends(
            &mut self,
            request: tonic::Request<super::ListFriendsRequest>,
        ) -> Result<tonic::Response<super::FriendList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/ListFriends");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List groups based on given filters."]
        pub async fn list_groups(
            &mut self,
            request: tonic::Request<super::ListGroupsRequest>,
        ) -> Result<tonic::Response<super::GroupList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/ListGroups");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List all users that are part of a group."]
        pub async fn list_group_users(
            &mut self,
            request: tonic::Request<super::ListGroupUsersRequest>,
        ) -> Result<tonic::Response<super::GroupUserList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListGroupUsers",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List leaderboard records."]
        pub async fn list_leaderboard_records(
            &mut self,
            request: tonic::Request<super::ListLeaderboardRecordsRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecordList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListLeaderboardRecords",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List leaderboard records that belong to a user."]
        pub async fn list_leaderboard_records_around_owner(
            &mut self,
            request: tonic::Request<super::ListLeaderboardRecordsAroundOwnerRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecordList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListLeaderboardRecordsAroundOwner",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Fetch list of running matches."]
        pub async fn list_matches(
            &mut self,
            request: tonic::Request<super::ListMatchesRequest>,
        ) -> Result<tonic::Response<super::MatchList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/ListMatches");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Fetch list of notifications."]
        pub async fn list_notifications(
            &mut self,
            request: tonic::Request<super::ListNotificationsRequest>,
        ) -> Result<tonic::Response<super::NotificationList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListNotifications",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List publicly readable storage objects in a given collection."]
        pub async fn list_storage_objects(
            &mut self,
            request: tonic::Request<super::ListStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjectList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListStorageObjects",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List current or upcoming tournaments."]
        pub async fn list_tournaments(
            &mut self,
            request: tonic::Request<super::ListTournamentsRequest>,
        ) -> Result<tonic::Response<super::TournamentList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListTournaments",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List tournament records."]
        pub async fn list_tournament_records(
            &mut self,
            request: tonic::Request<super::ListTournamentRecordsRequest>,
        ) -> Result<tonic::Response<super::TournamentRecordList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListTournamentRecords",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List tournament records for a given owner."]
        pub async fn list_tournament_records_around_owner(
            &mut self,
            request: tonic::Request<super::ListTournamentRecordsAroundOwnerRequest>,
        ) -> Result<tonic::Response<super::TournamentRecordList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListTournamentRecordsAroundOwner",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " List groups the current user belongs to."]
        pub async fn list_user_groups(
            &mut self,
            request: tonic::Request<super::ListUserGroupsRequest>,
        ) -> Result<tonic::Response<super::UserGroupList>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ListUserGroups",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Promote a set of users in a group to the next role up."]
        pub async fn promote_group_users(
            &mut self,
            request: tonic::Request<super::PromoteGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/PromoteGroupUsers",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Get storage objects."]
        pub async fn read_storage_objects(
            &mut self,
            request: tonic::Request<super::ReadStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjects>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/ReadStorageObjects",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Execute a Lua function on the server."]
        pub async fn rpc_func(
            &mut self,
            request: tonic::Request<super::Rpc>,
        ) -> Result<tonic::Response<super::Rpc>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/RpcFunc");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove the custom ID from the social profiles on the current user's account."]
        pub async fn unlink_custom(
            &mut self,
            request: tonic::Request<super::AccountCustom>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UnlinkCustom");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove the device ID from the social profiles on the current user's account."]
        pub async fn unlink_device(
            &mut self,
            request: tonic::Request<super::AccountDevice>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UnlinkDevice");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove the email+password from the social profiles on the current user's account."]
        pub async fn unlink_email(
            &mut self,
            request: tonic::Request<super::AccountEmail>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UnlinkEmail");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove Facebook from the social profiles on the current user's account."]
        pub async fn unlink_facebook(
            &mut self,
            request: tonic::Request<super::AccountFacebook>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/UnlinkFacebook",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove Apple's GameCenter from the social profiles on the current user's account."]
        pub async fn unlink_game_center(
            &mut self,
            request: tonic::Request<super::AccountGameCenter>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/UnlinkGameCenter",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove Google from the social profiles on the current user's account."]
        pub async fn unlink_google(
            &mut self,
            request: tonic::Request<super::AccountGoogle>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UnlinkGoogle");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Remove Steam from the social profiles on the current user's account."]
        pub async fn unlink_steam(
            &mut self,
            request: tonic::Request<super::AccountSteam>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UnlinkSteam");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Update fields in the current user's account."]
        pub async fn update_account(
            &mut self,
            request: tonic::Request<super::UpdateAccountRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UpdateAccount");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Update fields in a given group."]
        pub async fn update_group(
            &mut self,
            request: tonic::Request<super::UpdateGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path =
                http::uri::PathAndQuery::from_static("/rearward.api.RearwardService/UpdateGroup");
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Write a record to a leaderboard."]
        pub async fn write_leaderboard_record(
            &mut self,
            request: tonic::Request<super::WriteLeaderboardRecordRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecord>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/WriteLeaderboardRecord",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Write objects into the storage engine."]
        pub async fn write_storage_objects(
            &mut self,
            request: tonic::Request<super::WriteStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjectAcks>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/WriteStorageObjects",
            );
            self.inner.unary(request, path, codec).await
        }
        #[doc = " Write a record to a tournament."]
        pub async fn write_tournament_record(
            &mut self,
            request: tonic::Request<super::WriteTournamentRecordRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecord>, tonic::Status> {
            self.ready().await?;
            let codec = tonic::codec::ProstCodec::new();
            let path = http::uri::PathAndQuery::from_static(
                "/rearward.api.RearwardService/WriteTournamentRecord",
            );
            self.inner.unary(request, path, codec).await
        }
    }
    impl<T: Clone> Clone for RearwardServiceClient<T> {
        fn clone(&self) -> Self {
            Self {
                inner: self.inner.clone(),
            }
        }
    }
}
#[doc = r" Generated server implementations."]
pub mod server {
    #![allow(unused_variables, dead_code, missing_docs)]
    use tonic::codegen::*;
    #[doc = "Generated trait containing gRPC methods that should be implemented for use with RearwardServiceServer."]
    #[async_trait]
    pub trait RearwardService: Send + Sync + 'static {
        #[doc = " Add friends by ID or username to a user's account."]
        async fn add_friends(
            &self,
            request: tonic::Request<super::AddFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add users to a group."]
        async fn add_group_users(
            &self,
            request: tonic::Request<super::AddGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with a custom id against the server."]
        async fn authenticate_custom(
            &self,
            request: tonic::Request<super::AuthenticateCustomRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with a device id against the server."]
        async fn authenticate_device(
            &self,
            request: tonic::Request<super::AuthenticateDeviceRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with an email+password against the server."]
        async fn authenticate_email(
            &self,
            request: tonic::Request<super::AuthenticateEmailRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with a Facebook OAuth token against the server."]
        async fn authenticate_facebook(
            &self,
            request: tonic::Request<super::AuthenticateFacebookRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with Apple's GameCenter against the server."]
        async fn authenticate_game_center(
            &self,
            request: tonic::Request<super::AuthenticateGameCenterRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with Google against the server."]
        async fn authenticate_google(
            &self,
            request: tonic::Request<super::AuthenticateGoogleRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Authenticate a user with Steam against the server."]
        async fn authenticate_steam(
            &self,
            request: tonic::Request<super::AuthenticateSteamRequest>,
        ) -> Result<tonic::Response<super::Session>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Block one or more users by ID or username."]
        async fn block_friends(
            &self,
            request: tonic::Request<super::BlockFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Create a new group with the current user as the owner."]
        async fn create_group(
            &self,
            request: tonic::Request<super::CreateGroupRequest>,
        ) -> Result<tonic::Response<super::Group>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Delete one or more users by ID or username."]
        async fn delete_friends(
            &self,
            request: tonic::Request<super::DeleteFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Delete a group by ID."]
        async fn delete_group(
            &self,
            request: tonic::Request<super::DeleteGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Delete a leaderboard record."]
        async fn delete_leaderboard_record(
            &self,
            request: tonic::Request<super::DeleteLeaderboardRecordRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Delete one or more notifications for the current user."]
        async fn delete_notifications(
            &self,
            request: tonic::Request<super::DeleteNotificationsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Delete one or more objects by ID or username."]
        async fn delete_storage_objects(
            &self,
            request: tonic::Request<super::DeleteStorageObjectsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Fetch the current user's account."]
        async fn get_account(
            &self,
            request: tonic::Request<()>,
        ) -> Result<tonic::Response<super::Account>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Fetch zero or more users by ID and/or username."]
        async fn get_users(
            &self,
            request: tonic::Request<super::GetUsersRequest>,
        ) -> Result<tonic::Response<super::Users>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " A healthcheck which load balancers can use to check the service."]
        async fn healthcheck(
            &self,
            request: tonic::Request<()>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Import Facebook friends and add them to a user's account."]
        async fn import_facebook_friends(
            &self,
            request: tonic::Request<super::ImportFacebookFriendsRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Immediately join an open group, or request to join a closed one."]
        async fn join_group(
            &self,
            request: tonic::Request<super::JoinGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Attempt to join an open and running tournament."]
        async fn join_tournament(
            &self,
            request: tonic::Request<super::JoinTournamentRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Kick a set of users from a group."]
        async fn kick_group_users(
            &self,
            request: tonic::Request<super::KickGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Leave a group the user is a member of."]
        async fn leave_group(
            &self,
            request: tonic::Request<super::LeaveGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add a custom ID to the social profiles on the current user's account."]
        async fn link_custom(
            &self,
            request: tonic::Request<super::AccountCustom>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add a device ID to the social profiles on the current user's account."]
        async fn link_device(
            &self,
            request: tonic::Request<super::AccountDevice>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add an email+password to the social profiles on the current user's account."]
        async fn link_email(
            &self,
            request: tonic::Request<super::AccountEmail>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add Facebook to the social profiles on the current user's account."]
        async fn link_facebook(
            &self,
            request: tonic::Request<super::LinkFacebookRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add Apple's GameCenter to the social profiles on the current user's account."]
        async fn link_game_center(
            &self,
            request: tonic::Request<super::AccountGameCenter>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add Google to the social profiles on the current user's account."]
        async fn link_google(
            &self,
            request: tonic::Request<super::AccountGoogle>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Add Steam to the social profiles on the current user's account."]
        async fn link_steam(
            &self,
            request: tonic::Request<super::AccountSteam>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List a channel's message history."]
        async fn list_channel_messages(
            &self,
            request: tonic::Request<super::ListChannelMessagesRequest>,
        ) -> Result<tonic::Response<super::ChannelMessageList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List all friends for the current user."]
        async fn list_friends(
            &self,
            request: tonic::Request<super::ListFriendsRequest>,
        ) -> Result<tonic::Response<super::FriendList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List groups based on given filters."]
        async fn list_groups(
            &self,
            request: tonic::Request<super::ListGroupsRequest>,
        ) -> Result<tonic::Response<super::GroupList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List all users that are part of a group."]
        async fn list_group_users(
            &self,
            request: tonic::Request<super::ListGroupUsersRequest>,
        ) -> Result<tonic::Response<super::GroupUserList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List leaderboard records."]
        async fn list_leaderboard_records(
            &self,
            request: tonic::Request<super::ListLeaderboardRecordsRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecordList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List leaderboard records that belong to a user."]
        async fn list_leaderboard_records_around_owner(
            &self,
            request: tonic::Request<super::ListLeaderboardRecordsAroundOwnerRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecordList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Fetch list of running matches."]
        async fn list_matches(
            &self,
            request: tonic::Request<super::ListMatchesRequest>,
        ) -> Result<tonic::Response<super::MatchList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Fetch list of notifications."]
        async fn list_notifications(
            &self,
            request: tonic::Request<super::ListNotificationsRequest>,
        ) -> Result<tonic::Response<super::NotificationList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List publicly readable storage objects in a given collection."]
        async fn list_storage_objects(
            &self,
            request: tonic::Request<super::ListStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjectList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List current or upcoming tournaments."]
        async fn list_tournaments(
            &self,
            request: tonic::Request<super::ListTournamentsRequest>,
        ) -> Result<tonic::Response<super::TournamentList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List tournament records."]
        async fn list_tournament_records(
            &self,
            request: tonic::Request<super::ListTournamentRecordsRequest>,
        ) -> Result<tonic::Response<super::TournamentRecordList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List tournament records for a given owner."]
        async fn list_tournament_records_around_owner(
            &self,
            request: tonic::Request<super::ListTournamentRecordsAroundOwnerRequest>,
        ) -> Result<tonic::Response<super::TournamentRecordList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " List groups the current user belongs to."]
        async fn list_user_groups(
            &self,
            request: tonic::Request<super::ListUserGroupsRequest>,
        ) -> Result<tonic::Response<super::UserGroupList>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Promote a set of users in a group to the next role up."]
        async fn promote_group_users(
            &self,
            request: tonic::Request<super::PromoteGroupUsersRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Get storage objects."]
        async fn read_storage_objects(
            &self,
            request: tonic::Request<super::ReadStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjects>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Execute a Lua function on the server."]
        async fn rpc_func(
            &self,
            request: tonic::Request<super::Rpc>,
        ) -> Result<tonic::Response<super::Rpc>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove the custom ID from the social profiles on the current user's account."]
        async fn unlink_custom(
            &self,
            request: tonic::Request<super::AccountCustom>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove the device ID from the social profiles on the current user's account."]
        async fn unlink_device(
            &self,
            request: tonic::Request<super::AccountDevice>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove the email+password from the social profiles on the current user's account."]
        async fn unlink_email(
            &self,
            request: tonic::Request<super::AccountEmail>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove Facebook from the social profiles on the current user's account."]
        async fn unlink_facebook(
            &self,
            request: tonic::Request<super::AccountFacebook>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove Apple's GameCenter from the social profiles on the current user's account."]
        async fn unlink_game_center(
            &self,
            request: tonic::Request<super::AccountGameCenter>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove Google from the social profiles on the current user's account."]
        async fn unlink_google(
            &self,
            request: tonic::Request<super::AccountGoogle>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Remove Steam from the social profiles on the current user's account."]
        async fn unlink_steam(
            &self,
            request: tonic::Request<super::AccountSteam>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Update fields in the current user's account."]
        async fn update_account(
            &self,
            request: tonic::Request<super::UpdateAccountRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Update fields in a given group."]
        async fn update_group(
            &self,
            request: tonic::Request<super::UpdateGroupRequest>,
        ) -> Result<tonic::Response<()>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Write a record to a leaderboard."]
        async fn write_leaderboard_record(
            &self,
            request: tonic::Request<super::WriteLeaderboardRecordRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecord>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Write objects into the storage engine."]
        async fn write_storage_objects(
            &self,
            request: tonic::Request<super::WriteStorageObjectsRequest>,
        ) -> Result<tonic::Response<super::StorageObjectAcks>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
        #[doc = " Write a record to a tournament."]
        async fn write_tournament_record(
            &self,
            request: tonic::Request<super::WriteTournamentRecordRequest>,
        ) -> Result<tonic::Response<super::LeaderboardRecord>, tonic::Status> {
            Err(tonic::Status::unimplemented("Not yet implemented"))
        }
    }
    #[doc = "*"]
    #[doc = " The Rearward RPC protocol service built with GRPC."]
    #[derive(Clone, Debug)]
    pub struct RearwardServiceServer<T: RearwardService> {
        inner: Arc<T>,
    }
    #[derive(Clone, Debug)]
    #[doc(hidden)]
    pub struct RearwardServiceServerSvc<T: RearwardService> {
        inner: Arc<T>,
    }
    impl<T: RearwardService> RearwardServiceServer<T> {
        #[doc = "Create a new RearwardServiceServer from a type that implements RearwardService."]
        pub fn new(inner: T) -> Self {
            let inner = Arc::new(inner);
            Self::from_shared(inner)
        }
        pub fn from_shared(inner: Arc<T>) -> Self {
            Self { inner }
        }
    }
    impl<T: RearwardService> RearwardServiceServerSvc<T> {
        pub fn new(inner: Arc<T>) -> Self {
            Self { inner }
        }
    }
    impl<T: RearwardService, R> Service<R> for RearwardServiceServer<T> {
        type Response = RearwardServiceServerSvc<T>;
        type Error = Never;
        type Future = Ready<Result<Self::Response, Self::Error>>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, _: R) -> Self::Future {
            ok(RearwardServiceServerSvc::new(self.inner.clone()))
        }
    }
    impl<T: RearwardService> Service<http::Request<HyperBody>> for RearwardServiceServerSvc<T> {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = Never;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<HyperBody>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/rearward.api.RearwardService/AddFriends" => {
                    struct AddFriends<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AddFriendsRequest> for AddFriends<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddFriendsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.add_friends(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddFriends(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AddGroupUsers" => {
                    struct AddGroupUsers<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AddGroupUsersRequest>
                        for AddGroupUsers<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddGroupUsersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.add_group_users(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddGroupUsers(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateCustom" => {
                    struct AuthenticateCustom<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateCustomRequest>
                        for AuthenticateCustom<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateCustomRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_custom(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateCustom(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateDevice" => {
                    struct AuthenticateDevice<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateDeviceRequest>
                        for AuthenticateDevice<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateDeviceRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_device(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateDevice(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateEmail" => {
                    struct AuthenticateEmail<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateEmailRequest>
                        for AuthenticateEmail<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateEmailRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_email(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateEmail(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateFacebook" => {
                    struct AuthenticateFacebook<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateFacebookRequest>
                        for AuthenticateFacebook<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateFacebookRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_facebook(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateFacebook(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateGameCenter" => {
                    struct AuthenticateGameCenter<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateGameCenterRequest>
                        for AuthenticateGameCenter<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateGameCenterRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_game_center(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateGameCenter(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateGoogle" => {
                    struct AuthenticateGoogle<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateGoogleRequest>
                        for AuthenticateGoogle<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateGoogleRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_google(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateGoogle(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/AuthenticateSteam" => {
                    struct AuthenticateSteam<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::AuthenticateSteamRequest>
                        for AuthenticateSteam<T>
                    {
                        type Response = super::Session;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthenticateSteamRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.authenticate_steam(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AuthenticateSteam(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/BlockFriends" => {
                    struct BlockFriends<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::BlockFriendsRequest>
                        for BlockFriends<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BlockFriendsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.block_friends(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BlockFriends(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/CreateGroup" => {
                    struct CreateGroup<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::CreateGroupRequest> for CreateGroup<T> {
                        type Response = super::Group;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.create_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateGroup(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/DeleteFriends" => {
                    struct DeleteFriends<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::DeleteFriendsRequest>
                        for DeleteFriends<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteFriendsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_friends(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteFriends(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/DeleteGroup" => {
                    struct DeleteGroup<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::DeleteGroupRequest> for DeleteGroup<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteGroup(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/DeleteLeaderboardRecord" => {
                    struct DeleteLeaderboardRecord<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::DeleteLeaderboardRecordRequest>
                        for DeleteLeaderboardRecord<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteLeaderboardRecordRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_leaderboard_record(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteLeaderboardRecord(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/DeleteNotifications" => {
                    struct DeleteNotifications<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::DeleteNotificationsRequest>
                        for DeleteNotifications<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteNotificationsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_notifications(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteNotifications(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/DeleteStorageObjects" => {
                    struct DeleteStorageObjects<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::DeleteStorageObjectsRequest>
                        for DeleteStorageObjects<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteStorageObjectsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.delete_storage_objects(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteStorageObjects(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/GetAccount" => {
                    struct GetAccount<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<()> for GetAccount<T> {
                        type Response = super::Account;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_account(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAccount(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/GetUsers" => {
                    struct GetUsers<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::GetUsersRequest> for GetUsers<T> {
                        type Response = super::Users;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUsersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.get_users(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUsers(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/Healthcheck" => {
                    struct Healthcheck<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<()> for Healthcheck<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.healthcheck(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = Healthcheck(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ImportFacebookFriends" => {
                    struct ImportFacebookFriends<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ImportFacebookFriendsRequest>
                        for ImportFacebookFriends<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImportFacebookFriendsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.import_facebook_friends(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ImportFacebookFriends(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/JoinGroup" => {
                    struct JoinGroup<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::JoinGroupRequest> for JoinGroup<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::JoinGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.join_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = JoinGroup(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/JoinTournament" => {
                    struct JoinTournament<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::JoinTournamentRequest>
                        for JoinTournament<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::JoinTournamentRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.join_tournament(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = JoinTournament(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/KickGroupUsers" => {
                    struct KickGroupUsers<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::KickGroupUsersRequest>
                        for KickGroupUsers<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KickGroupUsersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.kick_group_users(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = KickGroupUsers(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LeaveGroup" => {
                    struct LeaveGroup<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::LeaveGroupRequest> for LeaveGroup<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LeaveGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.leave_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LeaveGroup(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkCustom" => {
                    struct LinkCustom<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountCustom> for LinkCustom<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountCustom>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_custom(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkCustom(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkDevice" => {
                    struct LinkDevice<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountDevice> for LinkDevice<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountDevice>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_device(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkDevice(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkEmail" => {
                    struct LinkEmail<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountEmail> for LinkEmail<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountEmail>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_email(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkEmail(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkFacebook" => {
                    struct LinkFacebook<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::LinkFacebookRequest>
                        for LinkFacebook<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LinkFacebookRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_facebook(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkFacebook(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkGameCenter" => {
                    struct LinkGameCenter<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountGameCenter>
                        for LinkGameCenter<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountGameCenter>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_game_center(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkGameCenter(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkGoogle" => {
                    struct LinkGoogle<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountGoogle> for LinkGoogle<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountGoogle>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_google(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkGoogle(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/LinkSteam" => {
                    struct LinkSteam<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountSteam> for LinkSteam<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountSteam>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.link_steam(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LinkSteam(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListChannelMessages" => {
                    struct ListChannelMessages<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListChannelMessagesRequest>
                        for ListChannelMessages<T>
                    {
                        type Response = super::ChannelMessageList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListChannelMessagesRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_channel_messages(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListChannelMessages(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListFriends" => {
                    struct ListFriends<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::ListFriendsRequest> for ListFriends<T> {
                        type Response = super::FriendList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListFriendsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_friends(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListFriends(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListGroups" => {
                    struct ListGroups<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::ListGroupsRequest> for ListGroups<T> {
                        type Response = super::GroupList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListGroupsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_groups(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListGroups(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListGroupUsers" => {
                    struct ListGroupUsers<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListGroupUsersRequest>
                        for ListGroupUsers<T>
                    {
                        type Response = super::GroupUserList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListGroupUsersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_group_users(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListGroupUsers(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListLeaderboardRecords" => {
                    struct ListLeaderboardRecords<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListLeaderboardRecordsRequest>
                        for ListLeaderboardRecords<T>
                    {
                        type Response = super::LeaderboardRecordList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListLeaderboardRecordsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_leaderboard_records(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListLeaderboardRecords(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListLeaderboardRecordsAroundOwner" => {
                    struct ListLeaderboardRecordsAroundOwner<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListLeaderboardRecordsAroundOwnerRequest>
                        for ListLeaderboardRecordsAroundOwner<T>
                    {
                        type Response = super::LeaderboardRecordList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ListLeaderboardRecordsAroundOwnerRequest,
                            >,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move {
                                inner.list_leaderboard_records_around_owner(request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListLeaderboardRecordsAroundOwner(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListMatches" => {
                    struct ListMatches<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::ListMatchesRequest> for ListMatches<T> {
                        type Response = super::MatchList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListMatchesRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_matches(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListMatches(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListNotifications" => {
                    struct ListNotifications<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListNotificationsRequest>
                        for ListNotifications<T>
                    {
                        type Response = super::NotificationList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListNotificationsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_notifications(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListNotifications(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListStorageObjects" => {
                    struct ListStorageObjects<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListStorageObjectsRequest>
                        for ListStorageObjects<T>
                    {
                        type Response = super::StorageObjectList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListStorageObjectsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_storage_objects(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListStorageObjects(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListTournaments" => {
                    struct ListTournaments<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListTournamentsRequest>
                        for ListTournaments<T>
                    {
                        type Response = super::TournamentList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTournamentsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_tournaments(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTournaments(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListTournamentRecords" => {
                    struct ListTournamentRecords<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListTournamentRecordsRequest>
                        for ListTournamentRecords<T>
                    {
                        type Response = super::TournamentRecordList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTournamentRecordsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_tournament_records(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTournamentRecords(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListTournamentRecordsAroundOwner" => {
                    struct ListTournamentRecordsAroundOwner<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListTournamentRecordsAroundOwnerRequest>
                        for ListTournamentRecordsAroundOwner<T>
                    {
                        type Response = super::TournamentRecordList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTournamentRecordsAroundOwnerRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move {
                                inner.list_tournament_records_around_owner(request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTournamentRecordsAroundOwner(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ListUserGroups" => {
                    struct ListUserGroups<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ListUserGroupsRequest>
                        for ListUserGroups<T>
                    {
                        type Response = super::UserGroupList;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListUserGroupsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.list_user_groups(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListUserGroups(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/PromoteGroupUsers" => {
                    struct PromoteGroupUsers<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::PromoteGroupUsersRequest>
                        for PromoteGroupUsers<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PromoteGroupUsersRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.promote_group_users(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PromoteGroupUsers(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/ReadStorageObjects" => {
                    struct ReadStorageObjects<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::ReadStorageObjectsRequest>
                        for ReadStorageObjects<T>
                    {
                        type Response = super::StorageObjects;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadStorageObjectsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.read_storage_objects(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadStorageObjects(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/RpcFunc" => {
                    struct RpcFunc<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::Rpc> for RpcFunc<T> {
                        type Response = super::Rpc;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<super::Rpc>) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.rpc_func(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RpcFunc(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkCustom" => {
                    struct UnlinkCustom<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountCustom> for UnlinkCustom<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountCustom>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_custom(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkCustom(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkDevice" => {
                    struct UnlinkDevice<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountDevice> for UnlinkDevice<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountDevice>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_device(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkDevice(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkEmail" => {
                    struct UnlinkEmail<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountEmail> for UnlinkEmail<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountEmail>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_email(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkEmail(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkFacebook" => {
                    struct UnlinkFacebook<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountFacebook> for UnlinkFacebook<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountFacebook>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_facebook(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkFacebook(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkGameCenter" => {
                    struct UnlinkGameCenter<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountGameCenter>
                        for UnlinkGameCenter<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountGameCenter>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_game_center(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkGameCenter(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkGoogle" => {
                    struct UnlinkGoogle<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountGoogle> for UnlinkGoogle<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountGoogle>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_google(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkGoogle(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UnlinkSteam" => {
                    struct UnlinkSteam<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::AccountSteam> for UnlinkSteam<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AccountSteam>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.unlink_steam(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlinkSteam(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UpdateAccount" => {
                    struct UpdateAccount<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::UpdateAccountRequest>
                        for UpdateAccount<T>
                    {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateAccountRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_account(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateAccount(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/UpdateGroup" => {
                    struct UpdateGroup<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService> tonic::server::UnaryService<super::UpdateGroupRequest> for UpdateGroup<T> {
                        type Response = ();
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateGroupRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.update_group(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateGroup(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/WriteLeaderboardRecord" => {
                    struct WriteLeaderboardRecord<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::WriteLeaderboardRecordRequest>
                        for WriteLeaderboardRecord<T>
                    {
                        type Response = super::LeaderboardRecord;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteLeaderboardRecordRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.write_leaderboard_record(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteLeaderboardRecord(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/WriteStorageObjects" => {
                    struct WriteStorageObjects<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::WriteStorageObjectsRequest>
                        for WriteStorageObjects<T>
                    {
                        type Response = super::StorageObjectAcks;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteStorageObjectsRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.write_storage_objects(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteStorageObjects(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/rearward.api.RearwardService/WriteTournamentRecord" => {
                    struct WriteTournamentRecord<T: RearwardService>(pub Arc<T>);
                    impl<T: RearwardService>
                        tonic::server::UnaryService<super::WriteTournamentRecordRequest>
                        for WriteTournamentRecord<T>
                    {
                        type Response = super::LeaderboardRecord;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteTournamentRecordRequest>,
                        ) -> Self::Future {
                            let inner = self.0.clone();
                            let fut = async move { inner.write_tournament_record(request).await };
                            Box::pin(fut)
                        }
                    }
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteTournamentRecord(inner);
                        let codec = tonic::codec::ProstCodec::new();
                        let mut grpc = tonic::server::Grpc::new(codec);
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    Ok(http::Response::builder()
                        .status(200)
                        .header("grpc-status", "12")
                        .body(tonic::body::BoxBody::empty())
                        .unwrap())
                }),
            }
        }
    }
}
